{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nexports.__esModule = true;\n\nvar React = require(\"react\");\n\nvar placeholders = require(\"./placeholders\");\n\nvar utils_1 = require(\"./utils\");\n\nvar ReactPlaceholder = function (_a) {\n  var _b = _a.delay,\n      delay = _b === void 0 ? 0 : _b,\n      _c = _a.type,\n      type = _c === void 0 ? 'text' : _c,\n      _d = _a.color,\n      color = _d === void 0 ? '#CDCDCD' : _d,\n      _e = _a.rows,\n      rows = _e === void 0 ? 3 : _e,\n      readyProp = _a.ready,\n      firstLaunchOnly = _a.firstLaunchOnly,\n      children = _a.children,\n      className = _a.className,\n      showLoadingAnimation = _a.showLoadingAnimation,\n      customPlaceholder = _a.customPlaceholder,\n      rest = __rest(_a, [\"delay\", \"type\", \"color\", \"rows\", \"ready\", \"firstLaunchOnly\", \"children\", \"className\", \"showLoadingAnimation\", \"customPlaceholder\"]);\n\n  var _f = React.useState(readyProp),\n      ready = _f[0],\n      setReady = _f[1];\n\n  var timeout = React.useRef(null);\n\n  var getFiller = function () {\n    var classes = showLoadingAnimation ? utils_1.joinClassNames('show-loading-animation', className) : className;\n\n    if (customPlaceholder && React.isValidElement(customPlaceholder)) {\n      var mergedCustomClasses = utils_1.joinClassNames(customPlaceholder.props.className, classes);\n      return React.cloneElement(customPlaceholder, {\n        className: mergedCustomClasses\n      });\n    } else if (customPlaceholder) {\n      return customPlaceholder;\n    }\n\n    var Placeholder = placeholders[type];\n    return React.createElement(Placeholder, __assign({}, rest, {\n      color: color,\n      rows: rows,\n      className: classes\n    }));\n  };\n\n  React.useEffect(function () {\n    if (!firstLaunchOnly && ready && !readyProp) {\n      if (delay && delay > 0) {\n        timeout.current = window.setTimeout(function () {\n          setReady(false);\n        }, delay);\n      } else {\n        setReady(false);\n      }\n    } else if (readyProp) {\n      if (timeout.current) {\n        window.clearTimeout(timeout.current);\n      }\n\n      if (!ready) {\n        setReady(true);\n      }\n    }\n  }, [firstLaunchOnly, ready, readyProp, delay]); // clear the timeout when the component unmounts\n\n  React.useEffect(function () {\n    return function () {\n      if (timeout.current) {\n        window.clearTimeout(timeout.current);\n      }\n    };\n  }, []); // Casting - workaround for DefinitelyTyped/react issue with\n  // FunctionComponents returning ReactElement, where they should be able to\n  // return ReactNode. Casting also doesn't introduce another layer in the\n  // component tree like another `<>children</>` workaround does.\n  //\n  // See https://github.com/DefinitelyTyped/DefinitelyTyped/issues/33006\n  // and https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18051\n\n  return ready ? children : getFiller();\n};\n\nexports[\"default\"] = ReactPlaceholder;","map":null,"metadata":{},"sourceType":"script"}